<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on Chandler Barlow</title>
    <link>//localhost:1313/tags/javascript/</link>
    <description>Recent content in Javascript on Chandler Barlow</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 May 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="//localhost:1313/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bringing the Maybe Monad to Typescript</title>
      <link>//localhost:1313/posts/maybe-monad-in-typescript/</link>
      <pubDate>Fri, 12 May 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/maybe-monad-in-typescript/</guid>
      <description>&lt;p&gt;Hello! In this blog post I am going to be showing an example of how to implement the Maybe Monad in Typescript. It seems tremendously common for anyone learning functional programming to write their own version of an &amp;ldquo;Explaining Monads&amp;rdquo; blog post. I am glad to keep up the tradition.&lt;/p&gt;&#xA;&lt;h3 id=&#34;why-worry-about-a-maybe-type-in-the-first-place&#34;&gt;Why worry about a Maybe type in the first place?&lt;/h3&gt;&#xA;&lt;p&gt;Good question! The day to day work of a web developer requires handling all kinds of values that may, or may not exist. Using a consistent unambiguous pattern for handling these potentially missing values is incredibly helpful. It not only makes your code easier to read, but less prone to errors as well.&lt;/p&gt;</description>
    </item>
    <item>
      <title>How to Use Javascript Prototypes</title>
      <link>//localhost:1313/posts/how-to-use-javascript-prototypes/</link>
      <pubDate>Wed, 14 Jul 2021 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/how-to-use-javascript-prototypes/</guid>
      <description>&lt;p&gt;What is the prototype chain? How do we define objects in JavaScript?&lt;br&gt;&#xA;Part of being a good developer is modularization. Splitting code apart and reusing functionality is key to writing solid maintainable code. One of the tools developers use to split code apart is Classes. In fact Classes are the main way programmers are taught to segment their code. This practice is so popular that many modern programming languages adhere to what’s called the Object Oriented Paradigm. When a language is Object Oriented it means that a majority of the features in the language center around the utilization of and the creation of classes/objects. Classes can inherit properties of other Classes, or even extend their functionality. Classes also get to keep bits of data private and “encapsulated” away from outside code. In the world of programming Object Oriented programming can be incredibly useful.&lt;/p&gt;</description>
    </item>
    <item>
      <title>When To Use Redux</title>
      <link>//localhost:1313/posts/when-to-use-redux/</link>
      <pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/when-to-use-redux/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;//localhost:1313/redux_img.jpeg&#34; alt=&#34;image&#34;&gt;&#xA;When should you use Redux in a React project?&lt;br&gt;&#xA;When using React, a state management library like Redux isn&amp;rsquo;t always necessary. Out of the box React provides a few solutions for managing state. Therefore, not every React project requires Redux. So, when should Redux be used?&#xA;The main indicator of whether Redux is necessary is how complex the data flow in a project is.&lt;br&gt;&#xA;&lt;strong&gt;State can be passed down&lt;/strong&gt;&lt;br&gt;&#xA;State can be passed to child components through props. If a child component needs some information, the parent can simply pass it to them.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
